<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>Plinko Clash</title>
    <style>
      :root {
        font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        background: #0f172a;
        color: #f8fafc;
      }

      body {
        margin: 0;
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        background: radial-gradient(circle at top, rgba(96, 165, 250, 0.15), transparent 70%);
      }

      .game-wrapper {
        width: min(520px, 90vw);
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      canvas {
        background: #020617;
        border: 2px solid #22d3ee;
        border-radius: 12px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.35);
      }

      .panel {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 10px;
        font-size: 14px;
      }

      .chip {
        padding: 8px 12px;
        background: rgba(15, 23, 42, 0.7);
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 8px;
      }

      .chip strong {
        display: block;
        font-size: 12px;
        letter-spacing: 0.02em;
        text-transform: uppercase;
        color: #94a3b8;
      }

      .instructions {
        font-size: 13px;
        color: #cbd5f5;
        line-height: 1.6;
      }
    </style>
  </head>
  <body>
    <div class="game-wrapper">
      <canvas id="game" width="420" height="560"></canvas>
      <div class="panel">
        <div class="chip">
          <strong>HP</strong>
          <span id="hp-readout">100</span>
        </div>
        <div class="chip">
          <strong>거리</strong>
          <span id="distance-readout">0 m</span>
        </div>
        <div class="chip">
          <strong>현재 색상</strong>
          <span id="color-readout">노랑</span>
        </div>
        <div class="chip">
          <strong>속도</strong>
          <span id="speed-readout">0.0</span>
        </div>
      </div>
      <div class="instructions">
        스페이스로 색상을 <em>노랑 → 파랑 → 빨강</em> 순으로 변경하세요. <br />
        노랑은 파랑에 승, 파랑은 빨강에 승, 빨강은 노랑에 승! 녹색 핀은 HP를 회복해요.<br />
        R 키로 게임을 다시 시작할 수 있습니다.
      </div>
    </div>

    <script>
      // ====== 밸런스 세팅 ======
      const SETTINGS = {
        canvasWidth: 420,
        canvasHeight: 560,
        maxHP: 50,
        initialRows: 22,
        rowSpacing: 72,
        firstRowOffset: 135,
        pinRadius: 16,
        pinColumnsPattern: [4, 3],
        pinColumnPadding: 30,
        pinGreenChance: 0.05,
        ballRadius: 18,
        baseGravity: 0.095,
        gravityGrowth: 0.000025,
        maxGravity: 0.55,
        horizontalDamp: 0.992,
        wallBounceFactor: -0.6,
        bounceStrength: {
          win: -4.8,
          draw: -6.0,
          lose: -3.2,
          heal: -5.2,
        },
        horizontalImpulse: {
          win: 1.05,
          draw: 1.6,
          lose: 0.95,
          heal: 1.2,
        },
        ascendGravityMultiplier: 1.3,
        descendGravityMultiplier: 1.5,
        hoverThreshold: 0.35,
        hoverDamp: 0.8,
        loseDamage: 10,
        drawDamage: 0,
        healAmount: 10,
        gravityDelta: 16.67,
        minDropSpeed: 0.5,
        pinCullMargin: 4,
      };
      // =========================

      const PLAYER_COLORS = [
        { name: 'blue', label: '파랑', hex: '#22d3ee' },
        { name: 'red', label: '빨강', hex: '#ef4444' },
      ];

      const COLOR_RULES = {
        blue: { beats: 'red', loses: null },
        red: { beats: 'blue', loses: null },
      };

      const PIN_COLORS = {
        blue: '#60a5fa',
        red: '#f87171',
        green: '#0f172a',
      };


      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      const hpEl = document.getElementById('hp-readout');
      const distanceEl = document.getElementById('distance-readout');
      const colorEl = document.getElementById('color-readout');
      const speedEl = document.getElementById('speed-readout');

      const state = {
        ball: {
          x: SETTINGS.canvasWidth / 2,
          y: 40,
          vx: 0,
          vy: 0.25,
        },
        hp: SETTINGS.maxHP,
        colorIndex: 0,
        pins: [],
        playing: true,
        lastTime: 0,
        distance: 0,
        lastPinCollided: null,
        rowPatternIndex: 0,
        nextRowY: SETTINGS.firstRowOffset,
        feedbackTimer: 0,
        lastOutcome: null,
      };

      function init() {
        canvas.width = SETTINGS.canvasWidth;
        canvas.height = SETTINGS.canvasHeight;
        resetGame();
        state.lastTime = performance.now();
        requestAnimationFrame(loop);
      }

      function buildInitialPins() {
        state.pins = [];
        state.rowPatternIndex = 0;
        state.nextRowY = SETTINGS.firstRowOffset;
        while (state.nextRowY < SETTINGS.canvasHeight + 80) {
          addPinRow();
        }
      }

      function addPinRow() {
        const pattern = SETTINGS.pinColumnsPattern;
        const cols = pattern[state.rowPatternIndex % pattern.length];
        const maxCols = Math.max(...pattern);
        const spacing =
          maxCols > 1
            ? (SETTINGS.canvasWidth - SETTINGS.pinColumnPadding * 2) / (maxCols - 1)
            : 0;
        const startX =
          SETTINGS.pinColumnPadding + (state.rowPatternIndex % 2 === 0 ? 0 : spacing / 2);
        for (let col = 0; col < cols; col += 1) {
          const x = startX + spacing * col;
          state.pins.push({
            id: `${state.rowPatternIndex}-${col}`,
            x,
            y: state.nextRowY,
            color: pickPinColor(),
          });
        }
        state.rowPatternIndex += 1;
        state.nextRowY += SETTINGS.rowSpacing;
      }

      function pickPinColor() {
        if (Math.random() < SETTINGS.pinGreenChance) return 'green';
        const keys = ['blue', 'red'];
        return keys[Math.floor(Math.random() * keys.length)];
      }

      function resetGame() {
        state.hp = SETTINGS.maxHP;
        state.distance = 0;
        state.ball.x = SETTINGS.canvasWidth / 2;
        state.ball.y = 40;
        state.ball.vx = 0;
        state.ball.vy = 0.25;
        state.playing = true;
        state.colorIndex = 0;
        state.lastPinCollided = null;
        buildInitialPins();
        updateHud();
        state.lastTime = performance.now();
        state.feedbackTimer = 0;
        state.lastOutcome = null;
      }

      function updateHud() {
        hpEl.textContent = `${Math.max(0, Math.floor(state.hp))}`;
        distanceEl.textContent = `${Math.floor(state.distance / 10)} m`;
        colorEl.textContent = PLAYER_COLORS[state.colorIndex].label;
        speedEl.textContent = Math.max(0, state.ball.vy).toFixed(2);
      }

      function loop(timestamp) {
        const delta = timestamp - state.lastTime || SETTINGS.gravityDelta;
        state.lastTime = timestamp;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (state.playing) {
          update(delta);
        }

        draw();
        requestAnimationFrame(loop);
      }

      function update(delta) {
        applyGravity(delta);
        moveBall(delta);
        checkCollisions();
        updateFeedback(delta);
        updateHud();

        if (state.hp <= 0) {
          state.playing = false;
        }
      }

      function applyGravity(delta) {
        const baseGravity =
          Math.min(
            SETTINGS.maxGravity,
            SETTINGS.baseGravity + state.distance * SETTINGS.gravityGrowth
          ) * (delta / SETTINGS.gravityDelta);
        const multiplier =
          state.ball.vy < 0 ? SETTINGS.ascendGravityMultiplier : SETTINGS.descendGravityMultiplier;
        state.ball.vy += baseGravity * multiplier;

        if (Math.abs(state.ball.vy) < SETTINGS.hoverThreshold) {
          state.ball.vy *= SETTINGS.hoverDamp;
        }
      }

      function moveBall(delta) {
        const deltaFactor = delta / SETTINGS.gravityDelta;
        const vy = state.ball.vy >= 0
          ? Math.max(SETTINGS.minDropSpeed, state.ball.vy)
          : state.ball.vy;
        const step = vy * deltaFactor;
        state.ball.x += state.ball.vx * deltaFactor;
        state.ball.y += step;
        if (step > 0) {
          state.distance += step;
        }
        state.ball.vx *= SETTINGS.horizontalDamp;

        // 벽 충돌
        const leftBound = SETTINGS.ballRadius;
        const rightBound = SETTINGS.canvasWidth - SETTINGS.ballRadius;
        if (state.ball.x < leftBound) {
          state.ball.x = leftBound;
          state.ball.vx *= SETTINGS.wallBounceFactor;
        } else if (state.ball.x > rightBound) {
          state.ball.x = rightBound;
          state.ball.vx *= SETTINGS.wallBounceFactor;
        }
        handleCamera();
      }

      function handleCamera() {
        const threshold = SETTINGS.canvasHeight * 0.65;
        if (state.ball.y > threshold) {
          const shift = state.ball.y - threshold;
          state.ball.y -= shift;
          state.pins.forEach((pin) => {
            pin.y -= shift;
          });
          state.nextRowY -= shift;
        }

        state.pins = state.pins.filter((pin) => pin.y > -80);
        while (getMaxPinY() < SETTINGS.canvasHeight + 80) {
          addPinRow();
        }
      }

      function getMaxPinY() {
        if (state.pins.length === 0) return -Infinity;
        return state.pins.reduce((max, pin) => Math.max(max, pin.y), -Infinity);
      }

      function checkCollisions() {
        const radiusSum = SETTINGS.ballRadius + SETTINGS.pinRadius;
        let released = true;
        for (const pin of state.pins) {
          const dx = state.ball.x - pin.x;
          const dy = state.ball.y - pin.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist <= radiusSum) {
            if (state.lastPinCollided !== pin.id) {
              resolveCollision(pin, dx, dy);
              state.lastPinCollided = pin.id;
            }
            released = false;
            break;
          }
        }

        if (released) {
          state.lastPinCollided = null;
        }
      }

      function resolveCollision(pin, dx, dy) {
        const playerColor = PLAYER_COLORS[state.colorIndex].name;
        let outcome = 'draw';
        if (pin.color === 'green') {
          outcome = 'heal';
        } else if (pin.color === playerColor) {
          outcome = 'draw';
        } else {
          outcome = 'lose';
        }

        if (outcome === 'win' || outcome === 'lose') {
          state.lastOutcome = outcome;
          state.feedbackTimer = 900;
        }

        switch (outcome) {
          case 'lose':
            state.hp -= SETTINGS.loseDamage;
            break;
          case 'draw':
            // no HP change on same color
            break;
          case 'heal':
            state.hp = Math.min(SETTINGS.maxHP, state.hp + SETTINGS.healAmount);
            break;
        }

        state.hp = Math.max(0, state.hp);
        applyBounce(outcome, dx, dy);
        cullPinsAbove(pin.y);
      }

      function updateFeedback(delta) {
        if (state.feedbackTimer > 0) {
          state.feedbackTimer = Math.max(0, state.feedbackTimer - delta);
          if (state.feedbackTimer === 0) {
            state.lastOutcome = null;
          }
        }
      }

      function applyBounce(outcome, dx, dy) {
        const direction = Math.sign(dx) || (Math.random() < 0.5 ? -1 : 1);
        state.ball.vx += direction * SETTINGS.horizontalImpulse[outcome];
        state.ball.vy = SETTINGS.bounceStrength[outcome];
      }

      function cullPinsAbove(y) {
        const margin = SETTINGS.pinCullMargin;
        state.pins = state.pins.filter((pin) => pin.y > y + margin);
      }

      function draw() {
        drawPins();
        drawBall();
        drawSpeechBubble();
        drawOverlay();
      }

      function drawPins() {
        for (const pin of state.pins) {
          drawColorToken(pin.color, pin.x, pin.y, SETTINGS.pinRadius);
        }
      }

      function drawBall() {
        const color = PLAYER_COLORS[state.colorIndex];
        drawColorToken(color.name, state.ball.x, state.ball.y, SETTINGS.ballRadius);
      }

      function drawColorToken(type, x, y, radius) {
        ctx.beginPath();
        ctx.fillStyle = PIN_COLORS[type] || '#f8fafc';
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#0f172a';
        ctx.lineWidth = 2;
        ctx.stroke();

        if (type === 'green') {
          drawHealIcon(x, y, radius * 0.9);
        } else {
          drawIcon(type, x, y, radius * 0.75);
        }
      }

      function drawIcon(type, cx, cy, size) {
        if (type === 'green') {
          drawHealIcon(cx, cy, size);
          return;
        }
        ctx.save();
        ctx.lineWidth = 2.4;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.strokeStyle = '#0f172a';
        ctx.fillStyle = '#0f172a';

        if (type === 'blue') {
          // 펼친 손
          ctx.beginPath();
          ctx.moveTo(cx - size * 0.5, cy + size * 0.4);
          ctx.lineTo(cx - size * 0.2, cy - size * 0.4);
          ctx.lineTo(cx, cy + size * 0.2);
          ctx.lineTo(cx + size * 0.2, cy - size * 0.6);
          ctx.lineTo(cx + size * 0.4, cy + size * 0.2);
          ctx.lineTo(cx + size * 0.5, cy - size * 0.2);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx - size * 0.5, cy + size * 0.4);
          ctx.quadraticCurveTo(cx - size * 0.2, cy + size * 0.6, cx + size * 0.3, cy + size * 0.6);
          ctx.stroke();
        } else if (type === 'red') {
          // 주먹
          ctx.beginPath();
          ctx.arc(cx, cy, size * 0.5, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }

      function drawHealIcon(cx, cy, size) {
        ctx.save();
        ctx.strokeStyle = '#f8fafc';
        ctx.lineWidth = 3;
        const half = size * 0.6;
        ctx.strokeRect(cx - half, cy - half, half * 2, half * 2);
        ctx.beginPath();
        ctx.moveTo(cx - half * 0.8, cy);
        ctx.lineTo(cx + half * 0.8, cy);
        ctx.moveTo(cx, cy - half * 0.8);
        ctx.lineTo(cx, cy + half * 0.8);
        ctx.stroke();
        ctx.restore();
      }

      function drawSpeechBubble() {
        if (!state.lastOutcome || state.lastOutcome === 'heal') return;
        const isWin = state.lastOutcome === 'win';
        const text = isWin ? 'NICE!' : 'SO SAD...';
        const bubbleWidth = 90;
        const bubbleHeight = 30;
        const x = Math.min(
          Math.max(state.ball.x - bubbleWidth / 2, 20),
          SETTINGS.canvasWidth - bubbleWidth - 20
        );
        const y = Math.max(state.ball.y - SETTINGS.ballRadius - 40, 20);

        ctx.save();
        ctx.globalAlpha = Math.min(1, state.feedbackTimer / 900 + 0.2);
        ctx.fillStyle = isWin ? 'rgba(34,197,94,0.9)' : 'rgba(248,113,113,0.9)';
        ctx.strokeStyle = '#0f172a';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.roundRect(x, y, bubbleWidth, bubbleHeight, 8);
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = '#0f172a';
        ctx.font = 'bold 14px Pretendard, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, x + bubbleWidth / 2, y + bubbleHeight / 2);
        ctx.restore();
      }

      function drawOverlay() {
        if (state.playing) return;
        ctx.fillStyle = 'rgba(2, 6, 23, 0.75)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#f8fafc';
        ctx.textAlign = 'center';
        ctx.font = '28px Pretendard, sans-serif';
        ctx.fillText('게임 오버', canvas.width / 2, canvas.height / 2 - 10);
        ctx.font = '16px Pretendard, sans-serif';
        ctx.fillText(
          `기록: ${Math.floor(state.distance / 10)} m`,
          canvas.width / 2,
          canvas.height / 2 + 20
        );
        ctx.fillText('R 키로 다시 시작하세요', canvas.width / 2, canvas.height / 2 + 44);
      }

      function cycleColor() {
        state.colorIndex = (state.colorIndex + 1) % PLAYER_COLORS.length;
        updateHud();
      }

      function setColorByName(name) {
        const index = PLAYER_COLORS.findIndex((c) => c.name === name);
        if (index !== -1) {
          state.colorIndex = index;
          updateHud();
        }
      }

      window.addEventListener('keydown', (evt) => {
        if (evt.code === 'Space') {
          evt.preventDefault();
          cycleColor();
        } else if (evt.code === 'KeyA') {
          evt.preventDefault();
          setColorByName('blue');
        } else if (evt.code === 'KeyS') {
          evt.preventDefault();
          setColorByName('red');
        } else if (evt.code === 'KeyR') {
          resetGame();
        }
      });

      init();
    </script>
  </body>
</html>
